[ { "title": "Android Bluetooth 연동", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/", "categories": "Android", "tags": "Android, 안드로이드, bluetooth, 블루투스, 연동, Service", "date": "2022-07-07 00:00:00 +0900", "snippet": "안드로이드 블루투스 기능에 대해 정리하였음.Android Developer에 있는 내용과 포그라운드 서비스를 이용하여 블루투스 기능을 구현함.1. 블루투스 권한 설정안드로이드 12부터 새로운 블루투스 권한이 추가됨.public void checkPermissions() { String[] permission_list = { Manifest.permission.BLUETOOTH_CONNECT, }; for (String permission : permission_list) { int check = checkCallingOrSelfPermission(permission); // 권한 혀용 여부 // 권한 거부 상태 if (check == PackageManager.PERMISSION_DENIED) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { requestPermissions(permission_list, 0); // 권한 허용 여부 Dialog 출력 } } else { // 권한 허용 상태 permission_state = 1; // 권한 허용 상태로 변경 } } }블루투스 권한을 설정해줘야 블루투스 기능 사용 가능.2. 앱에서 블루투스 켜기Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);startActivityForResult(intent, BT_REQUEST_ENABLE);// 거부 또는 허용을 눌렀을 때@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { case BT_REQUEST_ENABLE: if (resultCode == RESULT_OK) { //Toast.makeText(getApplicationContext(), \"블루투스 활성화\", Toast.LENGTH_LONG).show(); binding.tvBluetoothStatus.setTextColor(Color.GREEN); binding.tvBluetoothStatus.setText(\"Bluetooth ON\"); binding.btnSearch.setEnabled(true); } else if (resultCode == RESULT_CANCELED) { //Toast.makeText(getApplicationContext(), \"취소\", Toast.LENGTH_LONG).show(); binding.tvBluetoothStatus.setTextColor(Color.RED); binding.tvBluetoothStatus.setText(\"Bluetooth OFF\"); binding.btnSearch.setEnabled(false); } break; } super.onActivityResult(requestCode, resultCode, data); }앱에서 블루투스를 켤 수 있도록 설정해줌.3. 블루투스 장치 스캔 // 블루투스 장치 검색 브로드캐스트 리시버 설정 IntentFilter filter_search = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(receiver_search, filter_search); absBinding.btnSearch.setOnClickListener(new View.OnClickListener() { // 주변 블루투스 장치 검색 @Override public void onClick(View view) { if (!searchedBTArrayAdapter.isEmpty()) { searchedBluetoothDevice.clear(); searchedBTArrayAdapter.notifyDataSetChanged(); } search(); } }); public void search() { if (bluetoothAdapter.isDiscovering()) { // 이미 검색 중인 경우 bluetoothAdapter.cancelDiscovery(); // 검색 중지 } bluetoothAdapter.startDiscovery(); } private final BroadcastReceiver receiver_search = new BroadcastReceiver() { public void onReceive(Context context, Intent intent) { // 블루투스 장치 검색 리시버 String action = intent.getAction(); if (BluetoothDevice.ACTION_FOUND.equals(action)) { BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); @SuppressLint(\"MissingPermission\") String deviceName = device.getName(); String deviceHardwareAddress = device.getAddress(); // MAC address if(deviceName != null &amp;&amp; deviceHardwareAddress != null) { // 이름과 주소가 null이 아닌 경우에만 등록 Log.i(\"검색된 기기: \", deviceName); Log.i(\"검색된 기기 주소\", deviceHardwareAddress); searchedHashMap = new HashMap&lt;&gt;(); searchedHashMap.put(\"name\", deviceName); searchedHashMap.put(\"address\", deviceHardwareAddress); searchedHashMap.put(\"connectState\", \"연결 안됨\"); searchedBluetoothDevice.add(searchedHashMap); if(pairedBluetoothDevice.size() &gt; 0) { for(int i=0;i&lt;pairedBluetoothDevice.size();i++) { // 등록된 블루투스 장치들과 검색된 블루투스 장치들을 비교하여 중복된 값이 있으면 없앰 String name = pairedBluetoothDevice.get(i).get(\"name\"); String address = pairedBluetoothDevice.get(i).get(\"address\"); if(deviceName.equals(name) &amp;&amp; deviceHardwareAddress.equals(address)) { for(int j=0;j&lt;searchedBluetoothDevice.size();j++) { if (searchedBluetoothDevice.get(j).get(\"name\").equals(name)) { searchedBluetoothDevice.remove(j); } } } } } searchedBTArrayAdapter.notifyDataSetChanged(); } } } };블루투스를 켜야만 블루투스 장치 검색이 가능하도록 구현.4. 블루투스 장치 연결public ConnectThread(BluetoothDevice device, int pos, int div) { mmDevice = device; position = pos; // 선택한 장치 포지션 구분 division = div; // 등록된 기기 또는 검색된 기기 구분 BluetoothSocket tmp = null; try { tmp = createBluetoothSocket(mmDevice); } catch (IOException e) { Log.e(TAG, \"Socket's create() method failed\", e); } mmSocket = tmp; } public void run() { bluetoothAdapter.cancelDiscovery(); // 블루투스 장치 검색 중지 try { mmSocket.connect(); // 블루투스 장치 연결 } catch (IOException connectException) { try { mmSocket.close(); // 소켓 닫기 (BluetoothSearchActivity.context_BS).stopService(new Intent( (BluetoothSearchActivity.context_BS).getApplicationContext(), BluetoothConnectService.class)); // 백그라운드 장치 연결 서비스 중지 } catch (IOException closeException) { Log.e(TAG, \"Could not close the client socket\", closeException); } return; } // 블루투스 장치와 연결 성공 시 ConnectedThread 실행 manageConnectedSocket(mmSocket); }연결할 블루투스 장치를 누르면 포그라운드 서비스가 시작되고 장치에 연결하는 ConnectThread 실행.5. 연결된 블루투스 장치의 데이터 수신 public ConnectedThread(BluetoothSocket socket) { mmSocket = socket; InputStream tmpIn = null; OutputStream tmpOut = null; try { tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); } catch (IOException e) { } mmInStream = tmpIn; mmOutStream = tmpOut; } public void run() { readBufferPosition = 0; readBuffer = new byte[1024]; // 데이터를 수신하기 위한 버퍼 생성 while (true) { try { int byteAvailable = mmInStream.available(); // 데이터 수신 확인 if(byteAvailable &gt; 0) { // 데이터가 수신된 경우 byte[] bytes = new byte[byteAvailable]; // 입력 스트림에서 바이트 단위로 읽음 mmInStream.read(bytes); // 입력 스트림 바이트를 한 바이트씩 읽음 for(int i = 0; i &lt; byteAvailable; i++) { byte tempByte = bytes[i]; // 개행문자를 기준으로 나눔(한줄) if(tempByte == '\\n') { // readBuffer 배열을 encodedBytes로 복사 byte[] encodedBytes = new byte[readBufferPosition]; System.arraycopy(readBuffer, 0, encodedBytes, 0, encodedBytes.length); final String text = new String(encodedBytes, \"US-ASCII\"); // 인코딩된 바이트 배열을 문자열로 변환 readBufferPosition = 0; Log.i(\"수신받은 데이터 값 : \", text); ((MainActivity) MainActivity.context_main).runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText((MainActivity.context_main), \"수신 값: \" + text, Toast.LENGTH_SHORT).show(); } }); } // 개행 문자가 아닐 경우 else { readBuffer[readBufferPosition++] = tempByte; } } } Thread.sleep(80); // 0.08초 대기 } catch (IOException e) { break; } catch (InterruptedException e) { e.printStackTrace(); } catch (NullPointerException e) { e.printStackTrace(); } } }장치가 연결되어 있는 동안 ConnectedThread 실행되어 장치가 보내는 데이터 수신 가능.6. 참고 사이트안드로이드 블루투스 개요bugwhale.tistory코드는 여기서 확인 가능" }, { "title": "Android Git 연동", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-git-%EC%97%B0%EB%8F%99/", "categories": "Android", "tags": "Android, 안드로이드, git, 깃, github, 깃허브, 연동", "date": "2022-07-06 00:00:00 +0900", "snippet": "1. 깃허브 레포지토리 생성먼저 자신의 GitHub에 프로젝트를 올릴 레포지토리를 생성 후 레포지토리 URL 복사.2. 안드로이드 스튜디오 프로젝트 생성프로젝트 생성.VCS - Create Git Repository 선택 후 깃 레포지토리에 올릴 프로젝트 선택.VCS가 Git으로 바뀌고 Git 기능들 사용 가능.Git - Commit 선택 시 커밋할 파일들이 선택되고 Commit 또는 Commit and Push를 할 수 있음.Commit 또는 Commit and Push 선택 시 remote URL을 설정해야함.Define remote를 눌러 아까 복사했었던 URL 붙여넣기 후 Push.Pushed master to new branch origin/master란 Event Log가 뜨고 GitHub로 이동하면 정상적으로 Push가 된 것을 확인 할 수 있음." }, { "title": "Android View Binding", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%B7%B0%EB%B0%94%EC%9D%B8%EB%94%A9/", "categories": "Android", "tags": "Android, 안드로이드, View Binding, 뷰 바인딩, View, Binding, findViewById", "date": "2022-07-05 00:00:00 +0900", "snippet": "1. View Binding SettingAndroid Studio 3.6 버전부터 지원.View Binding은 findViewById를 대체 가능.build.gradle(Module)의 android 안에 viewBinding 설정 후 액티비티에서 View Binding 사용 가능.MainActivity에서 ActivityMainBinding 객체를 선언하여 사용.생성된 결합 클래스에 포함된 inflate()를 호출하여 액티비티에서 사용할 결합 클래스 인스턴스 생성.getRoot()를 호출하여 루트 뷰 참조 가져오기.각 결합 클래스는 XML파일의 이름을 카멜 표기법으로 변환 후 Binding을 추가한 이름으로 생성됨.* Example MainActivity : ActivityMainBinding SecondActivity : ActivitySecondBinding TestActivity : ActivityTestBinding GoodActivity : ActivityGoodBinding 2. View Binding AdvantagesfindViewById 말고 View Binding을 사용함으로써 얻을 수 있는 장점 Null Safety : 뷰의 직접 참조를 생성하므로 유효하지 않은 뷰 ID로 인해 null 포인터 예외가 발생할 위험 X Type safety : 각 바인딩 클래스에 있는 필드의 유형이 XML 파일에서 참조하는 뷰와 일치하여 클래스 변환 예외가 발생 X " }, { "title": "라이엇 API 호출", "url": "/posts/%EB%9D%BC%EC%9D%B4%EC%97%87-API-%ED%98%B8%EC%B6%9C/", "categories": "API", "tags": "League of Legends, LOL, riot, api", "date": "2022-07-01 00:00:00 +0900", "snippet": "1. Riot Developer PortalRiot Developer Portal에서 DEVELOPMENT API KEY 확인 가능. 라이엇 계정으로 로그인한 후 DEVELOPMENT API KEY를 복사 (만료 기한이 있으므로 기한 체크 필수)Riot Developer Portal APIS에서 라이엇 API들을 확인할 수 있음. League Of Legend API들만 정리하였음.2. League of Legends API1. 소환사 정보 가져오기 소환사 닉네임을 입력하면 해당 소환사의 정보가 출력됨. (Ex. 페이커 선수의 닉네임인 Hide on bush) id : 소환사의 지역에서 고유한 식별자 (encryptedSummonerId에 해당) accountId : encryptedAccountId에 해당 puuid : 모든 지역에서 고유한 식별자(encryptedPUUID, puuid에 해당) name : 소환사 닉네임 profileIconId : 프로필 사진 번호 revistionDate : 최근 활동 시간 summonerLevel : 소환사 레벨 (다른 API들도 출력값 동일)2. 소환사 랭크 정보 가져오기 encryptedSummonerId(id)값을 입력하면 소환사의 랭크 정보가 출력됨. (개인/2인 랭크와 자유 랭크) queueType : 개인/2인 랭크(RANKED_SOLO_5x5) 또는 자유 랭크 구분(RANKED_FLEX_SR) tier : 소환사의 랭크 티어 rank : 소환사의 티어 위치 leaguePoints : 소환사의 랭크 점수 wins : 소환사의 랭크 게임 이긴 홧수 losses : 소환사의 랭크 게임 진 횟수3. 소환사의 모든 챔피언 숙련도 정보 가져오기 encryptedSummonerId(id)값을 입력하면 모든 챔피언 숙련도 정보가 출력됨. championId : 챔피언 번호 championLevel : 챔피언의 숙련도 레벨 championPoints : 챔피언의 숙련도 점수 lastPlayTime : 마지막으로 플레이한 시간 tokensEarned : 얻은 챔피언 토큰 수 4. 소환사의 특정 챔피언 숙련도 정보 가져오기 encryptedSummonerId(id)와 championId값을 입력하면 해당 챔피언의 숙련도 레벨이 출력됨. 5. 소환사의 총 숙련도 레벨 가져오기 encryptedSummonerId(id)값을 입력하면 총 숙련도 레벨이 출력됨. 6. 소환사의 최근 게임 가져오기 puuid값을 입력하면 소환사의 최근 matchId들이 출력됨. 최대 100개까지 가져올 수 있음. (optional parameters들로 세부 설정 가능) startTime : 가져올 matchID의 시작 날짜 설정 endTime : 가져올 matchId의 마지막 날짜 설정 queue : 큐id type : 매치 타입(ranked, normal, tourney, tutorial) start : 스타트 인덱스 count : 가져올 matchId 수 7. 소환사의 특정 게임 정보 가져오기 matchId값을 입력하면 해당 게임의 상세 결과 정보가 출력됨. 각 소환사의 룬 및 킬, 데스, 어시스트 등의 다양한 정보들이 출력됨(너무 많은 정보들이라 생략). 8. 소환사의 현재 진행 중인 게임 정보 가져오기 encryptedSummonerId(id)값을 입력하면 현재 진행 중인 게임 정보가 출력됨. { \"gameId\": 6004577782, // 게임 id \"mapId\": 11, // 맵 id \"gameMode\": \"CLASSIC\", // CLASSIC : 소환사의 협곡, ARAM : 칼바람 나락 \"gameType\": \"MATCHED_GAME\", // PvP \"gameQueueConfigId\": 420, // 420: 개인/2인 랭크 게임, 430: 일반 게임, 440: 자유 랭크 게임, 450: 무작위 총력전 \"participants\": [ { \"teamId\": 100, // 블루팀 \"spell1Id\": 4, // 스펠1 id \"spell2Id\": 14, // 스펠2 id \"championId\": 39, // 챔피언 id \"profileIconId\": 4020, // 프로필 아이콘 id \"summonerName\": \"미 퍼\", // 소환사 이름 \"bot\": false, \"summonerId\": \"z5pOeHdhKf1OvmNujKhUhLEmypop6uUjo17hRfe_i14c4go\", // encryptedSummonerId \"gameCustomizationObjects\": [], \"perks\": { // 소환사가 설정한 룬 \"perkIds\": [ 8010, // 메인 룬 1 (Ex. 정복자) 9111, // 메인 룬 1 (Ex. 승전보) 9104, // 메인 룬 1 (Ex. 전설: 민첩함) 8299, // 메인 룬 1 (Ex. 최후의 저항) 8453, // 서브 룬 1 (Ex. 사냥의 증표) 8444, // 서브 룬 2 (Ex. 보물 사냥꾼) 5005, // 능력치 파편 1 5008, // 능력치 파편 2 5002 // 능력치 파편 3 ], \"perkStyle\": 8000, // 메인 룬(정밀, 지배, 마법, 결의, 영감) \"perkSubStyle\": 8400 // 서브 룬(정밀, 지배, 마법, 결의, 영감) } }, { \"teamId\": 200, // 레드 팀 // 블루팀 내용과 동일 \"perkSubStyle\": 8300 } }, ], \"observers\": { \"encryptionKey\": \"BJ1RPoh3p62KN6Z9xosbQy9H4aHNz65f\" }, \"platformId\": \"KR\", \"bannedChampions\": [ // 밴된 챔피언 목록(블루팀 pickTurn 1~5, 레드팀 pickTurn 6~10) { \"championId\": 69, \"teamId\": 100, \"pickTurn\": 1 }, { \"championId\": 112, \"teamId\": 100, \"pickTurn\": 5 }, { \"championId\": -1, // 챔피언 선택하지 않음 \"teamId\": 200, \"pickTurn\": 6 }, { \"championId\": 517, \"teamId\": 200, \"pickTurn\": 10 } ], \"gameStartTime\": 1657086677961, // 게임이 시작된 시간 \"gameLength\": 38} 게임 중이 아니라면 에러 코드 반환.9. 챔피언 로테이션 정보 가져오기API를 호출하면 로테이션 챔피언 목록이 출력됨. freeChampionIds : 무료 챔피언 id freeChampionIdsForNewPlayers : 초보자들을 위한 무료 챔피언 id maxNewPlayerLevel : 초보자 최대 레벨 상한치 10. 모든 소환사 랭킹 정보 가져오기 required parameters를 입력하면 설정한 티어에 속하는 소환사들의 랭크 정보 검색 결과가 출력됨. queue : 큐 타입(RANKED_SOLO_5x5, RANKED_TFT, RANKED_FLEX_SR, RANKED_FLEX_TT) tier : 아이언~챌린저 division : 1~4 page : 설정한 큐 타입과 티어의 검색 결과 페이지 숫자 설정 11. 소환사의 리그 랭킹 정보 가져오기 leagueId값을 입력하면 해당 리그 정보와 리그에 속해있는 소환사들의 랭크 정보를 확인할 수 있음. 3. League of Legends Game DataData Dragon에서 League of Legends 게임 데이터들을 확인 할 수 있음.Data Dragon canisback에서도 확인 가능. 패치별 게임 데이터를 찾을 수 있음.Data Dragon Version.json모든 챔피언.json모든 스펠.json모든 룬.json모든 아이템.json모든 맵.json모든 큐.json게임 모드.json게임 타입.json원하는 데이터의 id를 찾아 이미지 추출 가능.모든 티어 이미지 다운로드티어 이미지는 Data Dragon에서 최신 이미지를 찾을 수 없어 다운로드 후 사용." }, { "title": "포스팅 방법", "url": "/posts/%ED%8F%AC%EC%8A%A4%ED%8C%85-%EB%B0%A9%EB%B2%95/", "categories": "포스팅 방법", "tags": "md, markdown, post, posting", "date": "2022-05-01 00:00:00 +0900", "snippet": " 그림 넣기![example screenshot](/assets/img/postImage/example.png) 코드 블록```으로 감싸기public class example { public static void main(String[] args) { Log.d(\"example\", \"example\"); }} 링크[Google](https://google.com)Google 링크입니다.줄바꿈 : 3칸 이상 띄어쓰기" } ]
